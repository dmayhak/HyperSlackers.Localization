// T4resx.tt
//
// T4 template to generate classes for easy localization
//
// Requires SmartFormat and AutoRunCustomTool
//
// usage:
//     copy contents of this file to T4resx.tt in your resources project
//     set resx file build action to embedded resource
//     set custom tool to blank
//     set run custom tool to T4resx.tt


<#@ IntelliSenseLanguage processor="tangibleT4Editor" language="C#" #>
<#@ template debug="true" hostspecific="true" #>
<#@ include file="T4Toolbox.tt" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop.8.0" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="VSLangProj" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="EnvDTE80" #>
<#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Xml" #>

<#
    var serviceProvider = Host as IServiceProvider;
    if (serviceProvider != null) 
    {
        Dte = serviceProvider.GetService(typeof(SDTE)) as DTE;
    }

    // Fail if we couldn't get the DTE. This can happen when trying to run in TextTransform.exe
    if (Dte == null) 
    {
        throw new Exception("T4MResx can only execute through the Visual Studio host");
    }

    Project = GetProjectContainingT4File(Dte);

    if (Project == null) 
    {
        Error("Could not find the VS Project containing the T4 file.");
        return "Could not find the VS Project containing the T4 file.";
    }
    
    AppRoot = Path.GetDirectoryName(Project.FullName) + '\\';
    RootNamespace = Project.Properties.Item("RootNamespace").Value.ToString();

    List<ResxFile> rootFiles = CreateResxFileGraph();

    //return GetOutputForResxFile(rootFile, 0);

#>
// <auto-generated />
// This file was generated by a T4 template.
// Don't change it directly as your change would get overwritten.  Instead, make changes
// to the .tt file (i.e. the T4 template) and save it to regenerate this file.

// Host.TemplateFile = <#= Host.TemplateFile #>

// Make sure the compiler doesn't complain about missing Xml comments
#pragma warning disable 1591

namespace <#= RootNamespace #> 
{
    using SmartFormat;
    using System;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Linq;
    using System.Reflection;
    using System.Runtime.CompilerServices;
    using System.Text;
    using System.Threading;
    using System.Threading.Tasks;
    using System.Web;
    using System.Web.Mvc;

<# 
    foreach (var item in rootFiles)
    {
		WriteLine(GetOutputForResxFile(item, 0));
    }
#>
}

<#+
    const string Kind_PhysicalFolder = "{6BB5F8EF-4483-11D3-8BCF-00C04F8EC28C}";
    bool AlwaysKeepTemplateDirty = false;
    static DTE Dte;
    static Project Project;
    static string AppRoot;
    static string RootNamespace;


Project GetProjectContainingT4File(DTE dte) {

    // Find the .tt file's ProjectItem
    ProjectItem projectItem = dte.Solution.FindProjectItem(Host.TemplateFile);

    // If the .tt file is not opened, open it
    if (projectItem.Document == null)
    {
        projectItem.Open(Constants.vsViewKindCode);
    }

    if (AlwaysKeepTemplateDirty) 
    {
        // Mark the .tt file as unsaved. This way it will be saved and update itself next time the
        // project is built. Basically, it keeps marking itself as unsaved to make the next build work.
        // Note: this is certainly hacky, but is the best I could come up with so far.
        projectItem.Document.Saved = false;
    }

    return projectItem.ContainingProject;
}

List<Token> GetTokens(string value)
{
    List<Token> list = new List<Token>();

	if (!value.Contains("PARAMS:{"))
	{
		return list;
	}

	string parameters = value.Substring(value.IndexOf("PARAMS:{") + 8).Trim();
	if (!parameters.Contains("}"))
	{
		return list;
	}

	parameters = parameters.Substring(0, parameters.IndexOf("}"));

	string[] paramArray = parameters.Split(',');

	foreach (string parameter in paramArray)
	{
		Token token = new Token();

		string p = parameter.Trim();

		token.Type = "string"; // default to string
		if (p.StartsWith("("))
		{
			string[] parts = p.Substring(1).Split(')');
			token.Type = parts[0].Trim();
			token.Name = parts[1].Trim();
		}
		else
		{
			token.Name = p;
		}

		// if token name is a number (i.e. {0}, {1}, ...), then rename it to "param1", param2, etc...
		int nameAsInt = 0;
		if (int.TryParse(token.Name, out nameAsInt))
		{
			token.Name = "param_" + token.Name; // non-SmartFormat token
		}

		list.Add(token);
	}

    return list;
}

string GetInParams(List<Token> tokens)
{
    StringBuilder sb = new StringBuilder();

    foreach (Token token in tokens)
    {
         sb.Append(token.Type + " " + token.Name + ", ");
    }

    return sb.ToString().Trim().TrimEnd(',');
}

string GetOutParams(List<Token> tokens)
{
	if (tokens.Count() == 1 && tokens[0].Type == "object")
	{
		return tokens[0].Name;
	}

    StringBuilder sb = new StringBuilder();

	bool useSmartFormat = true; 

    foreach (Token token in tokens)
    {
		if (token.Name.StartsWith("param_"))
		{
			useSmartFormat = false;
		}
    }

	foreach (Token token in tokens)
    {
		if (useSmartFormat)
		{
			sb.Append(token.Name + " = " + token.Name + ", ");
		}
		else
		{
			sb.Append(token.Name + ", ");
		}
    }

	if (useSmartFormat)
	{
		return "new { " + sb.ToString().Trim().TrimEnd(',') + " }";
	}
	else
	{
		return sb.ToString().Trim().TrimEnd(',');
	}
}

struct Token
{
    public string Name { get; set; }
    public string Type { get; set; }
}

string MakeIntoValidIdentifier(string arbitraryString)
{
    var validIdentifier = Regex.Replace(arbitraryString, @"[^A-Za-z0-9-._]", " ");
    //validIdentifier = ConvertToPascalCase(validIdentifier);

    if (Regex.IsMatch(validIdentifier, @"^\d")) 
    {
        validIdentifier = "_" + validIdentifier;
    }

    return validIdentifier;
}

List<ResxFile> CreateResxFileGraph()
{
    List<ResxFile> rootFiles = new List<ResxFile>();

    List<ResxFile> allFiles = EnsureCompleteResxFileGraph(GetResxFilesRecursivly(Project.ProjectItems, string.Empty));

    foreach (ResxFile file in allFiles)
    {
        if (string.IsNullOrWhiteSpace(file.Path))
        {
            // root level file, add to root
            rootFiles.Add(file);
        }
        else
        {
            // non-root file, find parent to add it to
            string parentPath = "";
            string parentName = "";
            if (file.Path.Contains('.'))
            {
                parentPath = file.Path.Substring(0, file.Path.LastIndexOf("."));
                parentName = file.Path.Substring(file.Path.LastIndexOf(".") + 1);
            }
            else
            {
                parentName = file.Path;
            }
            ResxFile parent = allFiles.FirstOrDefault(f => f.Path == parentPath && f.Name == parentName);
            parent.Files.Add(file);
        }
    }

    return rootFiles;
}

List<ResxFile> EnsureCompleteResxFileGraph(List<ResxFile> files)
{
    List<ResxFile> allFiles = files.ToList();
    ResxFile[] existingFiles = files.ToArray();

    foreach (ResxFile item in existingFiles)
    {
        allFiles.AddRange(CreateMissingParentResxFiles(item, allFiles));
    }

    return allFiles;
}

List<ResxFile> CreateMissingParentResxFiles(ResxFile file, List<ResxFile> files)
{
    List<ResxFile> newFiles = new List<ResxFile>();

    if (!string.IsNullOrWhiteSpace(file.Path))
    {
        string[] pathParts = file.Path.Split('.');
        string path = string.Empty;
        string name = string.Empty;
        for (int i = 0; i < pathParts.Length; i++)
        {
            if (i > 0)
            {
                path = (path + "." + pathParts[i-1]).TrimStart('.');
                name = pathParts[i];
            }
            else
            {
                path = "";
                name = pathParts[i];
            }

            ResxFile existing = files.FirstOrDefault(f => f.Path == path && f.Name == name);
            if (existing.Name == null || existing.Name == string.Empty)
            {
                existing = new ResxFile { Name = name, Path = path, File = "", FilePath = "", FileType = "", Entries = new List<ResxEntry>(), Files = new List<ResxFile>() };
                newFiles.Add(existing);
            }
        }
    }

    return newFiles;
}

List<ResxFile> GetResxFilesRecursivly(ProjectItems items, string path)
{
    List<ResxFile> files = new List<ResxFile>();

    foreach(ProjectItem item in items)
    {
        // WriteLine( item.Name + ” ” + item.ProjectItems.Count );

        if(Path.GetExtension(item.Name) == ".resx")
        {
            // skip resource files except those for the default culture
            if(!Regex.IsMatch(item.Name, @".*\.[a-zA-z]{2}(-[a-zA-z]{2})?\.resx"))
            {
                var newpath = path.Length > 1 ? path.Substring(1) : "";
                var filePath = (string)item.Properties.Item("FullPath").Value;
                var parentFile = item.Name.Replace(".resx", "");
                var fileType = Path.GetExtension(parentFile);
                if(fileType != null && fileType != "")
                {
                    parentFile = parentFile.Replace(fileType, "");
                }
                parentFile = MakeIntoValidIdentifier(parentFile);

                ResxFile file = new ResxFile { Name = parentFile, Path = newpath, FilePath = filePath, FileType = fileType, File = parentFile, Entries = new List<ResxEntry>(), Files = new List<ResxFile>() };
                files.Add(file);

                GetResxfileEntries(item, file);
            }
        }
        if(item.Kind == Kind_PhysicalFolder)
        {
            files.AddRange(GetResxFilesRecursivly(item.ProjectItems, path + "." + item.Name));
        }
        else if (item.ProjectItems.Count > 0)
        {
            files.AddRange(GetResxFilesRecursivly(item.ProjectItems, path));
        }
    }

    return files;
}

void GetResxfileEntries(ProjectItem item, ResxFile file)
{
    var xml = new XmlDocument();
    xml.Load(file.FilePath);
    var entries = xml.DocumentElement.SelectNodes("//data");

    foreach (XmlElement entryElement in entries)
    {
        var entry = new ResxEntry
        {
            Name = MakeIntoValidIdentifier(entryElement.Attributes["name"].Value)
        };

        var valueElement = entryElement.SelectSingleNode("value");
        if(valueElement != null)
        {
            entry.Value = valueElement.InnerText;
        }

        var commentElement = entryElement.SelectSingleNode("comment");
        if(commentElement != null)
        {
            entry.Comment = commentElement.InnerText;
        }

        file.Entries.Add(entry);
    }
}

string GetOutputForResxFile(ResxFile file, int indentLevel)
{
    StringBuilder sb = new StringBuilder();
    string indent = GetIndent(indentLevel);
    string fullName = string.Format("{0}.{1}{2}", RootNamespace, file.Path + "." + file.Name, file.FileType).Replace("..", ".");

    sb.AppendLine(indent + "[DebuggerNonUserCodeAttribute()]");
    sb.AppendLine(indent + "[CompilerGeneratedAttribute()]");
    sb.AppendLine(indent + "public static class " + file.Name);
    sb.AppendLine(indent + "{");

    // write out all resx entries as function accessors
    if (file.Entries.Count > 0)
    {
        sb.AppendLine(indent + "\t" + "#region Resource Manager");
        sb.AppendLine(indent + "\t");
        sb.AppendLine(indent + "\t" + "private static global::System.Resources.ResourceManager resourceMan;");
        sb.AppendLine(indent);
        sb.AppendLine(indent + "\t" + "/// <summary> Returns the cached ResourceManager instance used by this class. </summary>");
        sb.AppendLine(indent + "\t" + "[global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]");
        sb.AppendLine(indent + "\t" + "internal static global::System.Resources.ResourceManager ResourceManager ");
        sb.AppendLine(indent + "\t" + "{");
        sb.AppendLine(indent + "\t\t" + "get");
        sb.AppendLine(indent + "\t\t" + "{");
        sb.AppendLine(indent + "\t\t\t" + "if (object.ReferenceEquals(" + file.Name + ".resourceMan, null))");
        sb.AppendLine(indent + "\t\t\t" + "{");
        sb.AppendLine(indent + "\t\t\t\t" + "global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager(\"" + fullName + "\", typeof(" + file.Name + ").Assembly);");
        sb.AppendLine(indent + "\t\t\t\t" + "// ???? global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager(\"\", typeof().Assembly);");
        sb.AppendLine(indent + "\t\t\t\t" + "resourceMan = temp;");
        sb.AppendLine(indent + "\t\t\t" + "}");
        sb.AppendLine(indent + "\t\t");
        sb.AppendLine(indent + "\t\t\t" + "return resourceMan;");
        sb.AppendLine(indent + "\t\t" + "}");
        sb.AppendLine(indent + "\t" + "}");
        sb.AppendLine(indent + "\t");
        sb.AppendLine(indent + "\t" + "/// <summary> Returns the formatted resource string. </summary>");
        sb.AppendLine(indent + "\t" + "[global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]");
        sb.AppendLine(indent + "\t" + "private static string GetResourceString(string key)");
        sb.AppendLine(indent + "\t" + "{");
        sb.AppendLine(indent + "\t\t" + "var culture = Thread.CurrentThread.CurrentCulture;");
        sb.AppendLine(indent + "\t\t" + "var str = ResourceManager.GetString(key, culture);");
        sb.AppendLine(indent + "\t\t");           
        sb.AppendLine(indent + "\t\t" + "return str;");
        sb.AppendLine(indent + "\t" + "}");
        sb.AppendLine(indent + "\t");
        sb.AppendLine(indent + "\t" + "/// <summary> Returns the formatted resource string. </summary>");
        sb.AppendLine(indent + "\t" + "[global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]");
        sb.AppendLine(indent + "\t" + "private static HtmlString GetResourceHtmlString(string key)");
        sb.AppendLine(indent + "\t" + "{");
        sb.AppendLine(indent + "\t\t" + "var str = GetResourceString(key);");
        sb.AppendLine(indent + "\t\t");                    
        sb.AppendLine(indent + "\t\t" + "return new HtmlString(str);");
        sb.AppendLine(indent + "\t" + "}");
        sb.AppendLine(indent + "\t");
        sb.AppendLine(indent + "\t" + "#endregion Resource Manager");
        sb.AppendLine(indent + "\t");

        sb.AppendLine(indent + "\t" + "#region Keys");
        sb.AppendLine(indent + "\t");
        foreach (ResxEntry item in file.Entries)
        {
			List<Token> tokens = new List<Token>();
			//bool haveComment = false;
			string comment = null;
			bool isHtml = false;

            // comment if any
            if(item.Comment != null)
            {
				//haveComment = true;
                //comment = indent + "\t" + string.Format("///<summary> {0} </summary>", item.Comment.Replace("\r\n", "\r\n" + indent + "\t///"));

				if (item.Comment.Contains("HTML:"))
				{
					isHtml = true;
				}

				tokens = GetTokens(item.Comment);
            }

			// always return the resource as a string, no parsing necessary
			sb.AppendLine(comment ?? (indent + "\t" + string.Format("/// <summary> {0} </summary>", item.Value.Replace("<", "&lt;").Replace(">", "&gt;").Replace("\r\n", "\r\n" + indent + "\t///\t"))));

			if(tokens != null && tokens.Count() > 0)
			{
				// function
				string inParams = GetInParams(tokens);
				string outParams = GetOutParams(tokens);

				if(isHtml)
				{
					sb.AppendLine(indent + "\t" + string.Format("public static HtmlString {0}({1}) {{ return new HtmlString(Smart.Format(GetResourceString(\"{0}\"), {2})); }}",  item.Name, inParams, outParams));
				}
				else
				{
					sb.AppendLine(indent + "\t" + string.Format("public static string {0}({1}) {{ return Smart.Format(GetResourceString(\"{0}\"), {2}); }}",  item.Name, inParams, outParams));
				}
			}
			else
			{
				if(isHtml)
				{
					sb.AppendLine(indent + "\t" + string.Format("public static HtmlString {0} {{ get {{ return GetResourceHtmlString(\"{0}\"); }} }}",  item.Name));
				}
				else
				{
					sb.AppendLine(indent + "\t" + string.Format("public static string {0} {{ get {{ return GetResourceString(\"{0}\"); }} }}",  item.Name));
				}
			}
        }
        sb.AppendLine(indent + "\t");
        sb.AppendLine(indent + "\t" + "#endregion Keys");


        // write out an inner class of just names
        sb.AppendLine(indent + "\t");
        sb.AppendLine(indent + "\t" + "#region Key Names");
        sb.AppendLine(indent + "\t");
        sb.AppendLine(indent + "\t" + "public static class KeyNames");
        sb.AppendLine(indent + "\t" + "{");
        foreach (ResxEntry item in file.Entries)
        {
            // comment if any
            if(item.Comment != null)
            {
                sb.AppendLine(indent + "\t\t" + string.Format("///<summary> {0} </summary>", item.Comment.Replace("\r\n", "\r\n" + indent + "\t///")));
            }
            
            sb.AppendLine(indent + "\t\t" + "public const string " + item.Name + " = \"" + item.Name + "\";");
        }
        sb.AppendLine(indent + "\t" + "}");
        sb.AppendLine(indent + "\t");
        sb.AppendLine(indent + "\t" + "#endregion Key Names");

        //// write out an inner class of names combined with the resource type name
        //sb.AppendLine(indent + "\t");
        //sb.AppendLine(indent + "\t" + "#region Key Names With Types");
        //sb.AppendLine(indent + "\t");
        //sb.AppendLine(indent + "\t" + "public static class TypedKeyNames");
        //sb.AppendLine(indent + "\t" + "{");
        //foreach (ResxEntry item in file.Entries)
        //{
        //    // comment if any
        //    if(item.Comment != null)
        //    {
        //        sb.AppendLine(indent + "\t\t" + string.Format("///<summary> {0} </summary>", item.Comment.Replace("\r\n", "\r\n" + indent + "\t///")));
        //    }
        //    
        //    sb.AppendLine(indent + "\t\t" + "public const string " + item.Name + " = \"" + fullName.Replace("System.", "System.Localized.").Replace(".Localized.Localized", ".Localized") + "|" + item.Name + "\";");
        //    //sb.AppendLine(indent + "\t\t" + "public static const ResourceNameWithType " + item.Name + " = new ResourceNameWithType(typeof(" + fullName + "), \"" + item.Name + "\");");
        //}
        //sb.AppendLine(indent + "\t" + "}");
        //sb.AppendLine(indent + "\t");
        //sb.AppendLine(indent + "\t" + "#endregion Key Names With Types");
    }

    //sb.AppendLine(indent + "\t");
    foreach (ResxFile item in file.Files)
    {
        sb.Append(GetOutputForResxFile(item, indentLevel + 1));
    }

    sb.AppendLine(indent + "}");
    sb.AppendLine(indent);

    return sb.ToString();
}

string GetIndent(int indentLevel)
{
    StringBuilder sb = new StringBuilder();

    for (int i = 0; i <= indentLevel; i++)
    {
        sb.Append("\t");
    }

    return sb.ToString();
}

struct ResxEntry
{
    public string Name { get; set; }
    public string Value { get; set; }
    public string Comment { get; set; }
}

struct ResxFile
{
    public string Name { get; set; }
    public string Path { get; set; }
    public string File { get; set; }
    public string FilePath { get; set; }
    public string FileType { get; set; }

    public List<ResxEntry> Entries { get; set; }
    public List<ResxFile> Files { get; set; }

}

#>
